<!DOCTYPE html>
<html>

<head>
    <title>Itowns - postprocessing</title>

    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="css/example.css">
    <link rel="stylesheet" type="text/css" href="css/LoadingScreen.css">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
    <div id="viewerDiv"></div>
    <script src="../dist/itowns.js"></script>
    <script src="js/GUI/LoadingScreen.js"></script>

    <script type="text/javascript">
        const graph = itowns.graph;

        // Graph showcase
        const outerGraph = new graph.Graph();

        // iTowns namespace defined here
        const placement = new graph.InputNode({
            coord: new itowns.Coordinates('EPSG:4326', 2.351323, 48.856712),
            range: 25_000_000,
        }, graph.BuiltinType.Placement);
        const viewerDiv = new graph.InputNode(document.getElementById('viewerDiv'));
        const viewNode = new graph.GlobeViewNode(viewerDiv, placement);
        outerGraph.set({placement, viewerDiv, viewNode});

        const div = viewerDiv.getOutput();
        const view = viewNode.getOutput('view', outerGraph);
        setupLoadingScreen(div, view);

        const renderer = {node: viewNode, output: 'renderer'};
        const render = new graph.RenderViewNode({node: viewNode, output: 'view'});
        outerGraph.set({render});

        // Subgraph
        const postProcessingGraph = new graph.Graph();

        // Coast highlight uniforms
        const sharpenWeight = new graph.InputNode(5);
        const sharpenOffset = new graph.InputNode(new itowns.THREE.Vector2(3., 0.));
        postProcessingGraph.set({sharpenWeight, sharpenOffset});

        // Screen shaders
        const warp = new graph.ScreenShaderNode(render, renderer, {
            fragmentShaderParts: {
                auxCode: /* glsl */`
uniform vec2 resolution;

vec4 warp(vec4 color) {
    return texture2D(tDiffuse, vUv + vec2(sin(floor(100. * vUv.x * vUv.x)), cos(floor(100. * vUv.y * vUv.y))) * vec2(5., 5.) / resolution);
}
`,
                main: /* glsl */'return warp(tex);'
            },
        });

        const coastHighlight = new graph.ScreenShaderNode(warp, renderer, {
            fragmentShaderParts: {
                uniforms: {uWeight: sharpenWeight, uOffset: sharpenOffset},
                auxCode: /* glsl */`
uniform vec2 resolution;

float getAvg(vec4 color) {
    return (color.r + color.g + color.b) / 3.0;
}

vec4 coastHighlight(vec4 color) {
    float mid = getAvg(color);
    float left = getAvg(texture2D(tDiffuse, vUv - uOffset / resolution));

    float diff = uWeight * (mid - left);
    float avg = (mid + left) / 2.0;

    float smoothed = max(0., diff - avg);
    float blueness = color.b / (color.r + color.g + color.b);

    return color + blueness * vec4(smoothed, smoothed, smoothed, 1.0);
}
`,
                main:  /* glsl */'return coastHighlight(tex);'
            },
        });

        const greyscale = new graph.ScreenShaderNode(coastHighlight, renderer, {
            fragmentShaderParts: {
                auxCode: /* glsl */`
vec4 greyscale(vec4 color) {
    float avg = (color.r + color.g + color.b) / 3.;
    return vec4(avg, avg, avg, 1.0);
}
`,
                main: /* glsl */'return greyscale(tex);'
            },
        });

        const uvcolor = new graph.ScreenShaderNode(greyscale, renderer, {
            fragmentShaderParts: {
                auxCode: /* glsl */`
vec4 uvcolor(vec4 color) {
    float r = min(color.r * vUv.x, 1.);
    float g = min(color.g * vUv.y, 1.);
    return vec4(r, g, color.b, 1.0);
}
`,
                main: /* glsl */'return uvcolor(tex);',
            },
        });

        postProcessingGraph.set({warp, coastHighlight, greyscale, uvcolor});

        const postProcessingSubGraph = graph.SubGraph.from(postProcessingGraph, 'Post-processing');
        const postProcessingGraphNode = new graph.SubGraphNode(outerGraph, postProcessingSubGraph, {
            uvcolor: {
                node: uvcolor,
                output: 'value',
            },
        });

        const renderFBO = new graph.ScreenShaderNode({node: postProcessingGraphNode, output: 'uvcolor'}, renderer, {toScreen: true});
        outerGraph.set({postProcessingGraphNode, renderFBO});

        // We expect coastHighlight, greyscale and uvcolor to be merged
        // warp will not be merged as it violates the no-offset access invariant
        postProcessingSubGraph.optimize(uvcolor, true);

        let frame = 0;
        view.render = function render() {
            outerGraph.getOutput(frame++, renderFBO);
            // Reach cruising speed before dumping so timing information is accurate
            if (frame == 10) {
                // window.open(outerGraph.dumpDotGraphvizLink(), '_blank', 'popup');
            }
        };

        itowns.Fetcher.json('./layers/JSONLayers/Ortho.json').then(function _(config) {
            config.source = new itowns.WMTSSource(config.source);
            var layer = new itowns.ColorLayer('Ortho', config);
            view.addLayer(layer);
        });
        itowns.Fetcher.json('./layers/JSONLayers/IGN_MNT.json').then(function _(config) {
            config.source = new itowns.WMTSSource(config.source);
            var layer = new itowns.ElevationLayer(config.id, config);
            view.addLayer(layer);
        });
    </script>
</body>

</html>
